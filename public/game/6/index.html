<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Voxel Architect PRO - HUD Mode</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff0055;
            --neon-green: #00ff9d;
            --neon-yellow: #ffcc00;
            --glass-bg: rgba(10, 20, 30, 0.75);
            --glass-border: 1px solid rgba(0, 243, 255, 0.3);
        }

        body { 
            margin: 0; 
            background: #050505; 
            overflow: hidden; 
            font-family: 'Roboto', sans-serif; 
            user-select: none;
        }

        /* ç•«å¸ƒå±¤ç´šç®¡ç† */
        #input_video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; opacity: 0.6; }
        #three_canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }
        #biometric_canvas { position: absolute; width: 100vw; height: 100vh; z-index: 10; transform: scaleX(-1); pointer-events: none; }

        /* å·¦å´ UI (ç‹€æ…‹) */
        #ui_left {
            position: absolute; top: 20px; left: 20px; z-index: 100;
            display: flex; flex-direction: column; gap: 10px;
            width: 220px;
        }

        /* å³å´ UI (æ•™å­¸é¢æ¿) */
        #ui_right {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
            pointer-events: none; /* è®“æ»‘é¼ ç©¿é€ç©ºç™½å€åŸŸ */
        }

        /* é€šç”¨é¢æ¿é¢¨æ ¼ */
        .hud-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            border: var(--glass-border);
            padding: 15px;
            border-radius: 8px; /* ç¨å¾®æ–¹ä¸€é»æ¯”è¼ƒåƒç§‘æŠ€é¢æ¿ */
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.1);
            color: #fff;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            pointer-events: auto; /* æ¢å¾©é»æ“Š */
        }

        /* å·¦å´æ¨™é¡Œ */
        .hud-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: var(--neon-blue);
            letter-spacing: 2px;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }

        .stat-row { display: flex; justify-content: space-between; margin: 4px 0; font-size: 13px; }
        .stat-val { font-family: 'Orbitron', monospace; color: var(--neon-green); font-weight: bold; }
        .mode-text { font-weight: bold; color: #fff; text-shadow: 0 0 5px var(--neon-blue); }

        .cyber-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
            width: 100%;
            margin-top: 5px;
            border-radius: 4px;
        }
        .cyber-btn:hover { background: var(--neon-blue); color: #000; }

        /* å³å´æ•™å­¸åˆ—è¡¨æ¨£å¼ */
        #tutorial_panel {
            width: 260px;
            transform: translateX(0);
            opacity: 1;
        }
        
        /* æ”¶æŠ˜ç‹€æ…‹ */
        #tutorial_panel.collapsed {
            transform: translateX(120%); /* å¾€å³æ»‘å‡º */
            opacity: 0;
        }

        .t-list { list-style: none; padding: 0; margin: 0; }
        .t-item { 
            display: flex; align-items: center; margin-bottom: 12px; 
            border-left: 3px solid #555; padding-left: 10px;
        }
        .t-icon { font-size: 20px; margin-right: 10px; min-width: 25px; text-align: center; }
        .t-content h4 { margin: 0; font-size: 14px; color: var(--neon-blue); font-weight: normal; }
        .t-content p { margin: 2px 0 0 0; font-size: 11px; color: #aaa; }

        /* å¹«åŠ©é–‹é—œæŒ‰éˆ• */
        #help_toggle {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: var(--glass-bg);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            font-family: 'Orbitron';
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            pointer-events: auto;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 10px rgba(0,243,255,0.2);
            transition: 0.3s;
        }
        #help_toggle:hover { background: var(--neon-blue); color: #000; }

        /* è¼‰å…¥æŒ‡ç¤ºå™¨ */
        #loading_indicator {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: var(--neon-blue); font-family: 'Orbitron'; font-size: 20px;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
            pointer-events: none; z-index: 200;
            display: flex; flex-direction: column; align-items: center;
        }
        .loader {
            border: 3px solid rgba(0,243,255,0.3); border-top: 3px solid var(--neon-blue);
            border-radius: 50%; width: 30px; height: 30px; margin-bottom: 10px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <div id="loading_indicator">
        <div class="loader"></div>
        <div>SYSTEM INITIALIZING...</div>
    </div>

    <div id="ui_left">
        <div class="hud-panel">
            <div class="hud-title">STATUS // V5.0</div>
            <div class="stat-row">æ¨¡å¼: <span id="mode" class="mode-text">åµæ¸¬ä¸­...</span></div>
            <div class="stat-row">æ–¹å¡Š: <span id="count" class="stat-val">0</span></div>
            <div class="stat-row" style="margin-top:8px; border-top:1px solid rgba(255,255,255,0.1); padding-top:5px;">
                <span id="hand_config_text" style="font-size:11px; color:#aaa;">å·¦æ‰‹ç§»å‹• / å³æ‰‹å»ºé€ </span>
            </div>
            <button id="swap_btn" class="cyber-btn">äº¤æ›å·¦å³æ‰‹</button>
        </div>
    </div>

    <div id="ui_right">
        <button id="help_toggle">?</button>
        
        <div id="tutorial_panel" class="hud-panel">
            <div class="hud-title" style="margin-bottom:10px;">COMMANDS // æŒ‡ä»¤</div>
            <div class="t-list">
                <div class="t-item" style="border-color: var(--neon-yellow);">
                    <div class="t-icon">âœŠ</div>
                    <div class="t-content">
                        <h4>æ¡æ‹³ (Grab)</h4>
                        <p>æŠ“å–ä¸¦ç§»å‹•ä¸–ç•Œ</p>
                    </div>
                </div>
                <div class="t-item" style="border-color: var(--neon-green);">
                    <div class="t-icon">ğŸ‘Œ</div>
                    <div class="t-content">
                        <h4>æåˆ (Pinch)</h4>
                        <p>é–‹å§‹å»ºé€ /æ‹‰å‹•æ–¹å¡Š</p>
                    </div>
                </div>
                <div class="t-item" style="border-color: var(--neon-pink);">
                    <div class="t-icon">â˜ï¸</div>
                    <div class="t-content">
                        <h4>é£ŸæŒ‡ (Point)</h4>
                        <p>åˆªé™¤æ–¹å¡Š</p>
                    </div>
                </div>
                <div class="t-item" style="border-color: #fff;">
                    <div class="t-icon">âœ‹</div>
                    <div class="t-content">
                        <h4>å¼µæ‰‹ (Palm)</h4>
                        <p>åœæ­¢/ç¢ºèª/ç§»å‹•æ¸¸æ¨™</p>
                    </div>
                </div>
            </div>
            <div style="margin-top:10px; font-size:10px; color:#666; text-align:right;">
                ä¿æŒæ‰‹éƒ¨è·é›¢é¡é ­ 50cm
            </div>
        </div>
    </div>

    <video id="input_video" autoplay playsinline></video>
    <canvas id="three_canvas"></canvas>
    <canvas id="biometric_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const bioCanvas = document.getElementById('biometric_canvas');
        const bioCtx = bioCanvas.getContext('2d');
        
        const uiElements = {
            mode: document.getElementById('mode'),
            count: document.getElementById('count'),
            config: document.getElementById('hand_config_text'),
            swap: document.getElementById('swap_btn'),
            tutorial: document.getElementById('tutorial_panel'),
            helpBtn: document.getElementById('help_toggle'),
            loader: document.getElementById('loading_indicator')
        };

        // UI é‚è¼¯
        let isHandSwapped = false;
        
        // æ•™å­¸é¢æ¿é–‹é—œ
        uiElements.helpBtn.onclick = () => {
            uiElements.tutorial.classList.toggle('collapsed');
        };

        // äº¤æ›å·¦å³æ‰‹
        uiElements.swap.onclick = () => {
            isHandSwapped = !isHandSwapped;
            uiElements.config.innerText = isHandSwapped ? "å·¦æ‰‹å»ºé€  / å³æ‰‹ç§»å‹•" : "å·¦æ‰‹ç§»å‹• / å³æ‰‹å»ºé€ ";
        };

        // å¹³æ»‘åƒæ•¸
        const SMOOTH_FACTOR = 0.3;
        let smoothedLeftHand = null;
        let smoothedRightHand = null;

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three_canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const voxelGroup = new THREE.Group();
        scene.add(voxelGroup);
        const currentSketch = new THREE.Group();
        voxelGroup.add(currentSketch);

        const gridSize = 1.0;
        const placedVoxels = new Map();

        const crosshair = new THREE.Mesh(
            new THREE.BoxGeometry(gridSize, gridSize, gridSize),
            new THREE.MeshBasicMaterial({ color: 0x00f3ff, wireframe: true, transparent: true, opacity: 0.6 })
        );
        scene.add(crosshair);

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0x00f3ff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);
        
        camera.position.z = 20;

        // Logic Variables
        let grabTimer = 0, isGrabbing = false, grabOffset = new THREE.Vector3();
        let buildTimer = 0, isBuilding = false, eraseTimer = 0;
        let startPinchPos = null, activeAxis = null;
        let sketchKeys = new Set();
        const HOLD_TIME = 400;
        const PINCH_THRESHOLD = 0.05;

        // Helper Functions
        function lerp(start, end, amt) { return (1 - amt) * start + amt * end; }
        function smoothLandmarks(prev, curr) {
            if (!prev) return curr;
            const smoothed = [];
            for (let i = 0; i < curr.length; i++) {
                smoothed.push({
                    x: lerp(prev[i].x, curr[i].x, SMOOTH_FACTOR),
                    y: lerp(prev[i].y, curr[i].y, SMOOTH_FACTOR),
                    z: lerp(prev[i].z, curr[i].z, SMOOTH_FACTOR)
                });
            }
            return smoothed;
        }

        function drawHUDCircle(ctx, x, y, progress, color) {
            if (progress <= 0) return;
            ctx.save();
            ctx.translate(x, y);
            ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255,255,255,0.2)"; ctx.lineWidth = 4; ctx.stroke();
            ctx.beginPath(); ctx.rotate(-Math.PI / 2);
            ctx.arc(0, 0, 30, 0, Math.PI * 2 * progress);
            ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.lineCap = "round"; ctx.stroke();
            ctx.restore();
        }

        function drawSkeleton(ctx, landmarks, color) {
            ctx.strokeStyle = color; ctx.lineWidth = 2;
            const CONNECTIONS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[9,10],[10,11],[11,12],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];
            ctx.beginPath();
            CONNECTIONS.forEach(([a, b]) => {
                ctx.moveTo(landmarks[a].x * bioCanvas.width, landmarks[a].y * bioCanvas.height);
                ctx.lineTo(landmarks[b].x * bioCanvas.width, landmarks[b].y * bioCanvas.height);
            });
            ctx.stroke();
            ctx.fillStyle = "#fff";
            landmarks.forEach(p => {
                ctx.beginPath(); ctx.arc(p.x * bioCanvas.width, p.y * bioCanvas.height, 2, 0, 2*Math.PI); ctx.fill();
            });
        }

        function onResults(results) {
            // éš±è— Loading
            uiElements.loader.style.display = 'none';
            
            bioCtx.clearRect(0, 0, bioCanvas.width, bioCanvas.height);
            if (!results.multiHandLandmarks) {
                crosshair.visible = false;
                smoothedLeftHand = null; smoothedRightHand = null;
                return;
            }

            let rawL = null, rawR = null;
            results.multiHandLandmarks.forEach((landmarks, idx) => {
                const label = results.multiHandedness[idx].label;
                if (label === 'Left') rawL = landmarks;
                if (label === 'Right') rawR = landmarks;
            });

            smoothedLeftHand = rawL ? smoothLandmarks(smoothedLeftHand, rawL) : null;
            smoothedRightHand = rawR ? smoothLandmarks(smoothedRightHand, rawR) : null;

            if (smoothedLeftHand) drawSkeleton(bioCtx, smoothedLeftHand, "rgba(0, 243, 255, 0.5)");
            if (smoothedRightHand) drawSkeleton(bioCtx, smoothedRightHand, "rgba(255, 0, 85, 0.5)");

            let lHand = isHandSwapped ? smoothedLeftHand : smoothedRightHand; 
            let rHand = isHandSwapped ? smoothedRightHand : smoothedLeftHand; 

            // ç§»å‹• (Move)
            if (lHand) {
                const isFist = lHand[8].y > lHand[5].y && lHand[12].y > lHand[9].y && lHand[16].y > lHand[13].y;
                const px = lHand[9].x * bioCanvas.width;
                const py = lHand[9].y * bioCanvas.height;
                const worldPos = new THREE.Vector3((0.5 - lHand[9].x) * 30, (0.5 - lHand[9].y) * 20, 0);

                if (isFist) {
                    grabTimer += 16;
                    drawHUDCircle(bioCtx, px, py, Math.min(grabTimer/HOLD_TIME, 1), "#ffcc00");
                    if (grabTimer > HOLD_TIME) {
                        if (!isGrabbing) { grabOffset.copy(voxelGroup.position).sub(worldPos); isGrabbing = true; }
                        voxelGroup.position.lerp(new THREE.Vector3().copy(worldPos).add(grabOffset), 0.2);
                        uiElements.mode.innerText = "ç§»å‹•ä¸­ (MOVE)";
                        uiElements.mode.style.color = "var(--neon-yellow)";
                    }
                } else {
                    isGrabbing = false; grabTimer = 0;
                }
            }

            // å»ºé€  (Build)
            if (rHand) {
                const indexTip = rHand[8], thumbTip = rHand[4];
                const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                const isPinching = dist < PINCH_THRESHOLD;
                const isPointing = rHand[8].y < rHand[6].y && rHand[12].y > rHand[10].y; 
                const isPalm = !isPinching && !isPointing && rHand[12].y < rHand[10].y;

                const px = indexTip.x * bioCanvas.width;
                const py = indexTip.y * bioCanvas.height;
                const rawPos = new THREE.Vector3((0.5 - indexTip.x) * 30, (0.5 - indexTip.y) * 20, 0);
                const localPos = voxelGroup.worldToLocal(rawPos.clone());
                const gx = Math.round(localPos.x / gridSize) * gridSize;
                const gy = Math.round(localPos.y / gridSize) * gridSize;
                
                crosshair.visible = true;
                crosshair.position.lerp(voxelGroup.localToWorld(new THREE.Vector3(gx, gy, 0)), 0.5);

                if (isPointing && !isPalm && !isBuilding) {
                    eraseTimer += 16;
                    drawHUDCircle(bioCtx, px, py, Math.min(eraseTimer/HOLD_TIME, 1), "#ff0055");
                    uiElements.mode.innerText = "åˆªé™¤ (ERASE)";
                    uiElements.mode.style.color = "var(--neon-pink)";
                    if (eraseTimer > HOLD_TIME) {
                        const key = `${gx.toFixed(1)},${gy.toFixed(1)},0.0`;
                        if (placedVoxels.has(key)) {
                            voxelGroup.remove(placedVoxels.get(key));
                            placedVoxels.delete(key);
                            uiElements.count.innerText = placedVoxels.size;
                            eraseTimer = 0;
                        }
                    }
                } else { eraseTimer = 0; }

                if (isPinching) {
                    buildTimer += 16;
                    drawHUDCircle(bioCtx, px, py, Math.min(buildTimer/HOLD_TIME, 1), "#00ff9d");
                    if (buildTimer > HOLD_TIME) {
                        uiElements.mode.innerText = "å»ºé€  (BUILD)";
                        uiElements.mode.style.color = "var(--neon-green)";
                        if (!isBuilding) {
                            startPinchPos = { x: gx, y: gy };
                            sketchKeys.clear();
                            isBuilding = true; activeAxis = null;
                        } else {
                            const dx = Math.abs(gx - startPinchPos.x), dy = Math.abs(gy - startPinchPos.y);
                            if (!activeAxis && (dx > 0.5 || dy > 0.5)) activeAxis = dx > dy ? 'x' : 'y';
                            let tx = gx, ty = gy;
                            if (activeAxis === 'x') ty = startPinchPos.y;
                            else if (activeAxis === 'y') tx = startPinchPos.x;
                            addSketchVoxel(tx, ty, 0);
                        }
                    }
                } else {
                    if (isBuilding) { commitVoxels(); isBuilding = false; }
                    buildTimer = 0;
                    if (!isPointing) {
                        uiElements.mode.innerText = "å°èˆª (READY)";
                        uiElements.mode.style.color = "#fff";
                    }
                }
            } else {
                if(isBuilding) { commitVoxels(); isBuilding = false; }
                buildTimer = 0; eraseTimer = 0;
            }
        }

        function addSketchVoxel(x, y, z) {
            const key = `${x.toFixed(1)},${y.toFixed(1)},${z.toFixed(1)}`;
            if (sketchKeys.has(key) || placedVoxels.has(key)) return;
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(gridSize*0.9, gridSize*0.9, gridSize*0.9), 
                new THREE.MeshBasicMaterial({ color: 0x00f3ff, wireframe: true, transparent: true, opacity: 0.5 })
            );
            mesh.position.set(x, y, z);
            currentSketch.add(mesh);
            sketchKeys.add(key);
        }

        function commitVoxels() {
            while(currentSketch.children.length > 0) {
                const f = currentSketch.children[0];
                const key = `${f.position.x.toFixed(1)},${f.position.y.toFixed(1)},0.0`;
                const cube = new THREE.Mesh(
                    new THREE.BoxGeometry(gridSize*0.95, gridSize*0.95, gridSize*0.95), 
                    new THREE.MeshStandardMaterial({ color: 0x112233, roughness: 0.3, metalness: 0.8, emissive: 0x00f3ff, emissiveIntensity: 0.2 })
                );
                cube.position.copy(f.position);
                cube.add(new THREE.LineSegments(new THREE.EdgesGeometry(cube.geometry), new THREE.LineBasicMaterial({ color: 0x00aaff })));
                voxelGroup.add(cube);
                placedVoxels.set(key, cube);
                currentSketch.remove(f);
            }
            uiElements.count.innerText = placedVoxels.size;
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                bioCanvas.width = videoElement.videoWidth;
                bioCanvas.height = videoElement.videoHeight;
                await hands.send({image: videoElement});
            },
            width: 1280, height: 720
        });
        cameraUtils.start(); // è‡ªå‹•å•Ÿå‹•

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>