<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Voxel Architect</title>
    <style>
        :root { --neon-blue: #00f0ff; --neon-pink: #ff0055; --neon-green: #00ffcc; }
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #input_video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; }
        #three_canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }
        /* 關鍵：此畫布已鏡像，所以 JS 繪圖坐標不應再手動反轉 */
        #biometric_canvas { position: absolute; width: 100vw; height: 100vh; z-index: 10; transform: scaleX(-1); pointer-events: none; }
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 100;
            color: #fff; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;
            backdrop-filter: blur(5px); border: 1px solid var(--neon-blue);
        }
        .stat-val { color: var(--neon-green); font-family: monospace; }
        #swap_btn {
            width: 100%; margin-top: 10px; background: transparent; border: 1px solid var(--neon-blue);
            color: var(--neon-blue); padding: 8px; cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-weight:bold; color:var(--neon-blue)">VOXEL ARCHITECT v4.2</div>
        <div style="margin:5px 0">狀態: <span id="mode" class="stat-val">準備中</span></div>
        <div style="margin:5px 0">方塊: <span id="count" class="stat-val">0</span></div>
        <div id="hand_info" style="font-size:12px; margin-top:10px">配置: 左(抓取) | 右(建造)</div>
        <button id="swap_btn">掉轉左右手</button>
    </div>

    <video id="input_video" autoplay playsinline></video>
    <canvas id="three_canvas"></canvas>
    <canvas id="biometric_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const bioCanvas = document.getElementById('biometric_canvas');
        const bioCtx = bioCanvas.getContext('2d');
        const modeEl = document.getElementById('mode');
        const countEl = document.getElementById('count');
        const handInfoEl = document.getElementById('hand_info');
        const swapBtn = document.getElementById('swap_btn');

        let isHandSwapped = false;
        swapBtn.onclick = () => {
            isHandSwapped = !isHandSwapped;
            handInfoEl.innerText = isHandSwapped ? "配置: 左(建造) | 右(抓取)" : "配置: 左(抓取) | 右(建造)";
        };

        // Three.js Scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three_canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const voxelGroup = new THREE.Group();
        scene.add(voxelGroup);
        const currentSketch = new THREE.Group();
        voxelGroup.add(currentSketch);

        const gridSize = 1.2;
        const placedVoxels = new Map();
        const crosshair = new THREE.Mesh(
            new THREE.BoxGeometry(gridSize, gridSize, gridSize),
            new THREE.MeshBasicMaterial({ color: 0x00f0ff, wireframe: true, transparent: true, opacity: 0.5 })
        );
        scene.add(crosshair);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(5,5,5);
        scene.add(light);
        camera.position.z = 25;

        // Logic variables
        let grabTimer = 0, isGrabbing = false, grabOffset = new THREE.Vector3();
        let buildTimer = 0, isBuilding = false, eraseTimer = 0, isErasing = false;
        let startPinchPos = null, activeAxis = null;
        let sketchKeys = new Set();
        const HOLD = 500;
        const PINCH_DIST = 0.04;

        function drawHUDCircle(ctx, x, y, progress, color) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, 40, -Math.PI/2, (-Math.PI/2) + (Math.PI * 2 * progress));
            ctx.lineWidth = 6; ctx.strokeStyle = color; ctx.stroke();
            // 內圈裝飾
            ctx.setLineDash([4, 4]);
            ctx.beginPath(); ctx.arc(x, y, 34, 0, Math.PI * 2); ctx.lineWidth = 1; ctx.stroke();
            ctx.restore();
        }

        function drawSkeleton(ctx, landmarks) {
            ctx.strokeStyle = "rgba(0, 240, 255, 0.4)";
            ctx.lineWidth = 2;
            const CONN = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[9,10],[10,11],[11,12],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];
            CONN.forEach(([a, b]) => {
                ctx.beginPath();
                ctx.moveTo(landmarks[a].x * bioCanvas.width, landmarks[a].y * bioCanvas.height);
                ctx.lineTo(landmarks[b].x * bioCanvas.width, landmarks[b].y * bioCanvas.height);
                ctx.stroke();
            });
        }

        function onResults(results) {
            bioCtx.clearRect(0, 0, bioCanvas.width, bioCanvas.height);
            crosshair.visible = false;

            if (!results.multiHandLandmarks) return;

            let physL = null, physR = null;
            results.multiHandLandmarks.forEach((landmarks, idx) => {
                const label = results.multiHandedness[idx].label;
                drawSkeleton(bioCtx, landmarks);
                if (label === 'Left') physL = landmarks;
                if (label === 'Right') physR = landmarks;
            });

            // 決定哪隻手負責什麼功能 (依據 UI 配置)
            // 註：MediaPipe 的 Left 手在鏡像畫面中看起來在右邊。
            let lHand = isHandSwapped ? physL : physR; 
            let rHand = isHandSwapped ? physR : physL; 

            // 左手邏輯 (抓取)
            if (lHand) {
                const isFist = lHand[8].y > lHand[6].y && lHand[12].y > lHand[10].y;
                const sx = lHand[9].x * bioCanvas.width;
                const sy = lHand[9].y * bioCanvas.height;
                const worldPos = new THREE.Vector3((0.5 - lHand[9].x) * 30, (0.5 - lHand[9].y) * 20, 0);

                if (isFist) {
                    grabTimer += 16;
                    drawHUDCircle(bioCtx, sx, sy, Math.min(grabTimer/HOLD, 1), "#ffbb00");
                    if (grabTimer > HOLD) {
                        if (!isGrabbing) { grabOffset.copy(voxelGroup.position).sub(worldPos); isGrabbing = true; }
                        voxelGroup.position.copy(worldPos).add(grabOffset);
                        modeEl.innerText = "拖拽中";
                    }
                } else { isGrabbing = false; grabTimer = 0; }
            }

            // 右手邏輯 (建造 - Z軸鎖定為0)
            if (rHand) {
                const dist = Math.sqrt(Math.pow(rHand[4].x-rHand[8].x,2) + Math.pow(rHand[4].y-rHand[8].y,2));
                const isPinching = dist < PINCH_DIST;
                const isPointing = rHand[8].y < rHand[6].y && rHand[12].y > rHand[10].y;
                const isPalm = rHand[8].y < rHand[6].y && rHand[12].y < rHand[10].y;
                
                const sx = rHand[8].x * bioCanvas.width;
                const sy = rHand[8].y * bioCanvas.height;
                
                const rawPos = new THREE.Vector3((0.5 - rHand[8].x) * 30, (0.5 - rHand[8].y) * 20, 0);
                const localPos = voxelGroup.worldToLocal(rawPos.clone());
                const gx = Math.round(localPos.x / gridSize) * gridSize;
                const gy = Math.round(localPos.y / gridSize) * gridSize;

                crosshair.position.copy(voxelGroup.localToWorld(new THREE.Vector3(gx, gy, 0)));
                crosshair.visible = true;

                if (isPointing && !isPalm) {
                    eraseTimer += 16;
                    drawHUDCircle(bioCtx, sx, sy, Math.min(eraseTimer/HOLD, 1), "#ff3333");
                    if (eraseTimer > HOLD) {
                        const key = `${gx.toFixed(1)},${gy.toFixed(1)},0.0`;
                        if (placedVoxels.has(key)) {
                            voxelGroup.remove(placedVoxels.get(key));
                            placedVoxels.delete(key);
                            countEl.innerText = placedVoxels.size;
                        }
                    }
                } else { eraseTimer = 0; }

                if (isPinching) {
                    buildTimer += 16;
                    drawHUDCircle(bioCtx, sx, sy, Math.min(buildTimer/HOLD, 1), "#00ffcc");
                    if (buildTimer > HOLD) {
                        if (!isBuilding) {
                            startPinchPos = { x: gx, y: gy };
                            sketchKeys.clear();
                            isBuilding = true;
                            activeAxis = null;
                        } else {
                            const dx = Math.abs(gx - startPinchPos.x), dy = Math.abs(gy - startPinchPos.y);
                            if (!activeAxis && (dx > 0.5 || dy > 0.5)) activeAxis = dx > dy ? 'x' : 'y';
                            let tx = startPinchPos.x, ty = startPinchPos.y;
                            if (activeAxis === 'x') tx = gx; else if (activeAxis === 'y') ty = gy;
                            addSketchVoxel(tx, ty, 0);
                        }
                        modeEl.innerText = "建築中";
                    }
                } else {
                    if (isPalm && isBuilding) commitVoxels();
                    if (isPalm) { isBuilding = false; buildTimer = 0; modeEl.innerText = "導航中"; }
                }
            }
        }

        function addSketchVoxel(x, y, z) {
            const key = `${x.toFixed(1)},${y.toFixed(1)},${z.toFixed(1)}`;
            if (sketchKeys.has(key) || placedVoxels.has(key)) return;
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(gridSize*0.9, gridSize*0.9, gridSize*0.9), new THREE.MeshBasicMaterial({ color: 0x00f0ff, wireframe: true }));
            mesh.position.set(x, y, z);
            currentSketch.add(mesh);
            sketchKeys.add(key);
        }

        function commitVoxels() {
            while(currentSketch.children.length > 0) {
                const f = currentSketch.children[0];
                const key = `${f.position.x.toFixed(1)},${f.position.y.toFixed(1)},0.0`;
                const g = new THREE.BoxGeometry(gridSize*0.95, gridSize*0.95, gridSize*0.95);
                const m = new THREE.MeshPhongMaterial({ color: 0x112233, emissive: 0x00f0ff, emissiveIntensity: 0.4 });
                const cube = new THREE.Mesh(g, m);
                cube.position.copy(f.position);
                cube.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0x00f0ff })));
                voxelGroup.add(cube);
                placedVoxels.set(key, cube);
                currentSketch.remove(f);
            }
            countEl.innerText = placedVoxels.size;
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });
        hands.onResults(onResults);

        new Camera(videoElement, {
            onFrame: async () => {
                bioCanvas.width = videoElement.videoWidth;
                bioCanvas.height = videoElement.videoHeight;
                await hands.send({image: videoElement});
            },
            width: 1280, height: 720
        }).start();

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>