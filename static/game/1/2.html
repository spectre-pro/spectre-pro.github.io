<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>極光戰機：霓虹入侵 (Aurora Neon)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --primary: #00f2ff;
            --secondary: #7000ff;
            --accent: #ff007a;
            --bg: #050505;
            --glass: rgba(255, 255, 255, 0.1);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            user-select: none;
            touch-action: none;
        }

        canvas {
            display: block;
            image-rendering: pixelated; /* 部分優化 */
        }

        /* 遊戲頂部資訊欄 */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .stat-box {
            background: var(--glass);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .label {
            font-size: 0.7rem;
            color: var(--primary);
            letter-spacing: 2px;
            display: block;
        }

        .value {
            font-size: 1.5rem;
            font-weight: 900;
            text-shadow: 0 0 10px var(--primary);
        }

        /* 血條 */
        #health-container {
            width: 150px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--primary));
            transition: width 0.3s ease;
        }

        /* 覆蓋層 (選單) */
        #overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(8px);
        }

        .menu {
            text-align: center;
            padding: 40px;
            border-radius: 30px;
            background: rgba(20, 20, 20, 0.6);
            border: 1px solid var(--primary);
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.2);
            max-width: 90%;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 900;
        }

        .score-display {
            font-size: 4rem;
            margin: 20px 0;
            color: var(--accent);
            display: none;
        }

        button {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin-top: 20px;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.5);
        }

        button:active {
            transform: scale(0.9);
        }

        .hint {
            font-size: 0.8rem;
            color: #888;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <div id="hud">
        <div class="stat-box">
            <span class="label">ARMOR</span>
            <div id="health-container"><div id="health-bar"></div></div>
            <span id="combo-text" style="color:var(--accent); font-size: 0.8rem; display:none;">COMBO x1</span>
        </div>
        <div class="stat-box">
            <span class="label">SCORE</span>
            <span id="score" class="value">0</span>
        </div>
    </div>

    <div id="overlay">
        <div class="menu">
            <h1 id="m-title">AURORA NEON</h1>
            <div id="m-score" class="score-display">0</div>
            <p id="m-desc">滑鼠/觸控移動 • 自動連發</p>
            <button id="start-btn">ENGAGE</button>
            <p class="hint">現代 HTML5 遊戲引擎測試版本</p>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * 遊戲核心系統 
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const healthBar = document.getElementById('health-bar');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('start-btn');
        const mTitle = document.getElementById('m-title');
        const mScore = document.getElementById('m-score');

        // 參數
        let gameActive = false;
        let score = 0;
        let health = 100;
        let combo = 0;
        let frame = 0;
        let shakeTime = 0;
        let particles = [];
        let enemies = [];
        let projectiles = [];
        let stars = [];
        let mouse = { x: -100, y: -100 };

        // 畫布尺寸更新
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initStars();
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 音效與觸覺回饋 ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSynthSound(freq, type, duration, vol = 0.1) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function triggerVibrate(ms) {
            if (navigator.vibrate) navigator.vibrate(ms);
        }

        // --- 物件類別 ---
        class Player {
            constructor() {
                this.x = canvas.width / 4;
                this.y = canvas.height / 2;
                this.radius = 18;
                this.targetY = this.y;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // 霓虹光暈
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00f2ff';
                
                // 船體
                ctx.beginPath();
                ctx.moveTo(25, 0);
                ctx.lineTo(-15, -15);
                ctx.lineTo(-8, 0);
                ctx.lineTo(-15, 15);
                ctx.closePath();
                ctx.fillStyle = '#fff';
                ctx.fill();

                // 噴射火焰
                const flameIdx = Math.sin(frame * 0.5) * 5;
                ctx.beginPath();
                ctx.moveTo(-10, 0);
                ctx.lineTo(-25 - flameIdx, 0);
                ctx.strokeStyle = '#00f2ff';
                ctx.lineWidth = 4;
                ctx.stroke();

                ctx.restore();
            }
            update() {
                // 平滑跟隨
                this.x += (mouse.x - this.x) * 0.15;
                this.y += (mouse.y - this.y) * 0.15;
                
                // 邊界限制
                this.x = Math.max(30, Math.min(canvas.width / 2, this.x));
                this.y = Math.max(30, Math.min(canvas.height - 30, this.y));
                
                this.draw();
            }
        }

        class Enemy {
            constructor() {
                this.radius = Math.random() * 15 + 10;
                this.x = canvas.width + this.radius;
                this.y = Math.random() * canvas.height;
                this.speed = Math.random() * 3 + 2 + (score / 5000);
                this.color = `hsl(${Math.random() * 60 + 280}, 100%, 60%)`; // 紫色系
                this.hp = Math.ceil(this.radius / 8);
            }
            update() {
                this.x -= this.speed;
                this.draw();
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(frame * 0.02);
                ctx.strokeStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                for(let i=0; i<6; i++){
                    const ang = (Math.PI*2/6)*i;
                    const r = i%2===0 ? this.radius : this.radius/2;
                    ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = 12;
            }
            update() {
                this.x += this.speed;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
                ctx.fillStyle = '#00f2ff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00f2ff';
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.velocity = { x: (Math.random()-0.5)*8, y: (Math.random()-0.5)*8 };
                this.alpha = 1;
                this.life = Math.random() * 0.05 + 0.02;
            }
            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= this.life;
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 2, 2);
                ctx.globalAlpha = 1;
            }
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < 80; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    s: Math.random() * 2
                });
            }
        }

        // --- 遊戲循環 ---
        let player = new Player();

        function spawn() {
            if (frame % Math.max(10, 40 - Math.floor(score/2000)) === 0) {
                enemies.push(new Enemy());
            }
            if (frame % 8 === 0) {
                projectiles.push(new Projectile(player.x + 20, player.y));
                playSynthSound(440, 'square', 0.05, 0.03);
            }
        }

        function animate() {
            if (!gameActive) return;
            requestAnimationFrame(animate);
            frame++;
            
            // 處理鏡頭震動
            ctx.save();
            if (shakeTime > 0) {
                ctx.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10);
                shakeTime--;
            }

            // 背景清理
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 星空
            stars.forEach(s => {
                s.x -= s.s;
                if(s.x < 0) s.x = canvas.width;
                ctx.fillStyle = '#fff';
                ctx.fillRect(s.x, s.y, s.s, s.s);
            });

            player.update();
            spawn();

            // 子彈處理
            projectiles.forEach((p, pi) => {
                p.update();
                if (p.x > canvas.width) projectiles.splice(pi, 1);
            });

            // 敵人與碰撞
            enemies.forEach((e, ei) => {
                e.update();

                // 撞擊玩家
                const dist = Math.hypot(player.x - e.x, player.y - e.y);
                if (dist < player.radius + e.radius) {
                    enemies.splice(ei, 1);
                    health -= 20;
                    shakeTime = 15;
                    triggerVibrate(100);
                    playSynthSound(100, 'sawtooth', 0.3, 0.2);
                    if (health <= 0) gameOver();
                }

                // 子彈擊中
                projectiles.forEach((p, pi) => {
                    const hitDist = Math.hypot(p.x - e.x, p.y - e.y);
                    if (hitDist < e.radius) {
                        for(let i=0; i<5; i++) particles.push(new Particle(p.x, p.y, e.color));
                        projectiles.splice(pi, 1);
                        e.hp--;
                        if(e.hp <= 0) {
                            score += 100;
                            enemies.splice(ei, 1);
                            playSynthSound(200, 'triangle', 0.1, 0.1);
                        }
                    }
                });

                if (e.x < -e.radius) {
                    enemies.splice(ei, 1);
                    health -= 5; // 漏掉敵人扣血
                }
            });

            // 粒子更新
            particles.forEach((p, i) => {
                p.update();
                if (p.alpha <= 0) particles.splice(i, 1);
            });

            // UI 更新
            scoreEl.innerText = score;
            healthBar.style.width = health + '%';
            
            ctx.restore();
        }

        // --- 控制監聽 ---
        const handleMove = (e) => {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            mouse.x = clientX;
            mouse.y = clientY;
        };

        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', (e) => {
            handleMove(e);
            e.preventDefault();
        }, { passive: false });

        function gameOver() {
            gameActive = false;
            overlay.style.display = 'flex';
            mTitle.innerText = "MISSION FAILED";
            mScore.innerText = score;
            mScore.style.display = 'block';
            startBtn.innerText = "RETRY";
        }

        startBtn.addEventListener('click', () => {
            // 初始化
            score = 0;
            health = 100;
            enemies = [];
            projectiles = [];
            particles = [];
            gameActive = true;
            overlay.style.display = 'none';
            audioCtx.resume();
            animate();
        });

        // 初始星空動畫
        function idle() {
            if (gameActive) return;
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            stars.forEach(s => {
                s.x -= s.s * 0.2;
                if(s.x < 0) s.x = canvas.width;
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(s.x, s.y, s.s, s.s);
            });
            requestAnimationFrame(idle);
        }
        idle();
    </script>
</body>
</html>